// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'body.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$BookBody {
  UniqueId get id => throw _privateConstructorUsedError;
  Name get name => throw _privateConstructorUsedError;
  Name get author => throw _privateConstructorUsedError;
  Way get way => throw _privateConstructorUsedError;
  double get progress => throw _privateConstructorUsedError; // Від 0 до 1
  Language get learnLanguage => throw _privateConstructorUsedError;
  Language get nativeLanguage => throw _privateConstructorUsedError;
  bool get isRead => throw _privateConstructorUsedError;
  DateTime get date => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BookBodyCopyWith<BookBody> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookBodyCopyWith<$Res> {
  factory $BookBodyCopyWith(BookBody value, $Res Function(BookBody) then) =
      _$BookBodyCopyWithImpl<$Res>;
  $Res call(
      {UniqueId id,
      Name name,
      Name author,
      Way way,
      double progress,
      Language learnLanguage,
      Language nativeLanguage,
      bool isRead,
      DateTime date});
}

/// @nodoc
class _$BookBodyCopyWithImpl<$Res> implements $BookBodyCopyWith<$Res> {
  _$BookBodyCopyWithImpl(this._value, this._then);

  final BookBody _value;
  // ignore: unused_field
  final $Res Function(BookBody) _then;

  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? author = freezed,
    Object? way = freezed,
    Object? progress = freezed,
    Object? learnLanguage = freezed,
    Object? nativeLanguage = freezed,
    Object? isRead = freezed,
    Object? date = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as Name,
      author: author == freezed
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as Name,
      way: way == freezed
          ? _value.way
          : way // ignore: cast_nullable_to_non_nullable
              as Way,
      progress: progress == freezed
          ? _value.progress
          : progress // ignore: cast_nullable_to_non_nullable
              as double,
      learnLanguage: learnLanguage == freezed
          ? _value.learnLanguage
          : learnLanguage // ignore: cast_nullable_to_non_nullable
              as Language,
      nativeLanguage: nativeLanguage == freezed
          ? _value.nativeLanguage
          : nativeLanguage // ignore: cast_nullable_to_non_nullable
              as Language,
      isRead: isRead == freezed
          ? _value.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool,
      date: date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
abstract class _$BookBodyCopyWith<$Res> implements $BookBodyCopyWith<$Res> {
  factory _$BookBodyCopyWith(_BookBody value, $Res Function(_BookBody) then) =
      __$BookBodyCopyWithImpl<$Res>;
  @override
  $Res call(
      {UniqueId id,
      Name name,
      Name author,
      Way way,
      double progress,
      Language learnLanguage,
      Language nativeLanguage,
      bool isRead,
      DateTime date});
}

/// @nodoc
class __$BookBodyCopyWithImpl<$Res> extends _$BookBodyCopyWithImpl<$Res>
    implements _$BookBodyCopyWith<$Res> {
  __$BookBodyCopyWithImpl(_BookBody _value, $Res Function(_BookBody) _then)
      : super(_value, (v) => _then(v as _BookBody));

  @override
  _BookBody get _value => super._value as _BookBody;

  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? author = freezed,
    Object? way = freezed,
    Object? progress = freezed,
    Object? learnLanguage = freezed,
    Object? nativeLanguage = freezed,
    Object? isRead = freezed,
    Object? date = freezed,
  }) {
    return _then(_BookBody(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as Name,
      author: author == freezed
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as Name,
      way: way == freezed
          ? _value.way
          : way // ignore: cast_nullable_to_non_nullable
              as Way,
      progress: progress == freezed
          ? _value.progress
          : progress // ignore: cast_nullable_to_non_nullable
              as double,
      learnLanguage: learnLanguage == freezed
          ? _value.learnLanguage
          : learnLanguage // ignore: cast_nullable_to_non_nullable
              as Language,
      nativeLanguage: nativeLanguage == freezed
          ? _value.nativeLanguage
          : nativeLanguage // ignore: cast_nullable_to_non_nullable
              as Language,
      isRead: isRead == freezed
          ? _value.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool,
      date: date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$_BookBody extends _BookBody {
  const _$_BookBody(
      {required this.id,
      required this.name,
      required this.author,
      required this.way,
      required this.progress,
      required this.learnLanguage,
      required this.nativeLanguage,
      required this.isRead,
      required this.date})
      : super._();

  @override
  final UniqueId id;
  @override
  final Name name;
  @override
  final Name author;
  @override
  final Way way;
  @override
  final double progress;
// Від 0 до 1
  @override
  final Language learnLanguage;
  @override
  final Language nativeLanguage;
  @override
  final bool isRead;
  @override
  final DateTime date;

  @override
  String toString() {
    return 'BookBody(id: $id, name: $name, author: $author, way: $way, progress: $progress, learnLanguage: $learnLanguage, nativeLanguage: $nativeLanguage, isRead: $isRead, date: $date)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BookBody &&
            const DeepCollectionEquality().equals(other.id, id) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality().equals(other.author, author) &&
            const DeepCollectionEquality().equals(other.way, way) &&
            const DeepCollectionEquality().equals(other.progress, progress) &&
            const DeepCollectionEquality()
                .equals(other.learnLanguage, learnLanguage) &&
            const DeepCollectionEquality()
                .equals(other.nativeLanguage, nativeLanguage) &&
            const DeepCollectionEquality().equals(other.isRead, isRead) &&
            const DeepCollectionEquality().equals(other.date, date));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(id),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(author),
      const DeepCollectionEquality().hash(way),
      const DeepCollectionEquality().hash(progress),
      const DeepCollectionEquality().hash(learnLanguage),
      const DeepCollectionEquality().hash(nativeLanguage),
      const DeepCollectionEquality().hash(isRead),
      const DeepCollectionEquality().hash(date));

  @JsonKey(ignore: true)
  @override
  _$BookBodyCopyWith<_BookBody> get copyWith =>
      __$BookBodyCopyWithImpl<_BookBody>(this, _$identity);
}

abstract class _BookBody extends BookBody {
  const factory _BookBody(
      {required final UniqueId id,
      required final Name name,
      required final Name author,
      required final Way way,
      required final double progress,
      required final Language learnLanguage,
      required final Language nativeLanguage,
      required final bool isRead,
      required final DateTime date}) = _$_BookBody;
  const _BookBody._() : super._();

  @override
  UniqueId get id => throw _privateConstructorUsedError;
  @override
  Name get name => throw _privateConstructorUsedError;
  @override
  Name get author => throw _privateConstructorUsedError;
  @override
  Way get way => throw _privateConstructorUsedError;
  @override
  double get progress => throw _privateConstructorUsedError;
  @override // Від 0 до 1
  Language get learnLanguage => throw _privateConstructorUsedError;
  @override
  Language get nativeLanguage => throw _privateConstructorUsedError;
  @override
  bool get isRead => throw _privateConstructorUsedError;
  @override
  DateTime get date => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$BookBodyCopyWith<_BookBody> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BookOriginBody {
  String get path => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BookOriginBodyCopyWith<BookOriginBody> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookOriginBodyCopyWith<$Res> {
  factory $BookOriginBodyCopyWith(
          BookOriginBody value, $Res Function(BookOriginBody) then) =
      _$BookOriginBodyCopyWithImpl<$Res>;
  $Res call({String path});
}

/// @nodoc
class _$BookOriginBodyCopyWithImpl<$Res>
    implements $BookOriginBodyCopyWith<$Res> {
  _$BookOriginBodyCopyWithImpl(this._value, this._then);

  final BookOriginBody _value;
  // ignore: unused_field
  final $Res Function(BookOriginBody) _then;

  @override
  $Res call({
    Object? path = freezed,
  }) {
    return _then(_value.copyWith(
      path: path == freezed
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$BookOriginBodyCopyWith<$Res>
    implements $BookOriginBodyCopyWith<$Res> {
  factory _$BookOriginBodyCopyWith(
          _BookOriginBody value, $Res Function(_BookOriginBody) then) =
      __$BookOriginBodyCopyWithImpl<$Res>;
  @override
  $Res call({String path});
}

/// @nodoc
class __$BookOriginBodyCopyWithImpl<$Res>
    extends _$BookOriginBodyCopyWithImpl<$Res>
    implements _$BookOriginBodyCopyWith<$Res> {
  __$BookOriginBodyCopyWithImpl(
      _BookOriginBody _value, $Res Function(_BookOriginBody) _then)
      : super(_value, (v) => _then(v as _BookOriginBody));

  @override
  _BookOriginBody get _value => super._value as _BookOriginBody;

  @override
  $Res call({
    Object? path = freezed,
  }) {
    return _then(_BookOriginBody(
      path: path == freezed
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_BookOriginBody extends _BookOriginBody {
  const _$_BookOriginBody({required this.path}) : super._();

  @override
  final String path;

  @override
  String toString() {
    return 'BookOriginBody(path: $path)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BookOriginBody &&
            const DeepCollectionEquality().equals(other.path, path));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(path));

  @JsonKey(ignore: true)
  @override
  _$BookOriginBodyCopyWith<_BookOriginBody> get copyWith =>
      __$BookOriginBodyCopyWithImpl<_BookOriginBody>(this, _$identity);
}

abstract class _BookOriginBody extends BookOriginBody {
  const factory _BookOriginBody({required final String path}) =
      _$_BookOriginBody;
  const _BookOriginBody._() : super._();

  @override
  String get path => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$BookOriginBodyCopyWith<_BookOriginBody> get copyWith =>
      throw _privateConstructorUsedError;
}
